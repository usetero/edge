# https://taskfile.dev

version: "3"

vars:
  PROJECT_NAME: edge
  BUILD_DIR: zig-out

tasks:
  default:
    desc: "Build the project in debug mode"
    aliases: [b]
    cmds:
      - zig build

  build:
    desc: "Build the project with specified optimization"
    aliases: [build-opt]
    cmds:
      - zig build -Doptimize={{.OPTIMIZE | default "Debug"}}

  build:protos:
    desc: "Build the project with protos"
    cmds:
      - zig build -Dgen-proto=true gen-proto

  build:release:
    desc: "Build the project in release mode (ReleaseFast)"
    aliases: [br, release]
    cmds:
      - zig build -Doptimize=ReleaseFast

  build:safe:
    desc: "Build the project in ReleaseSafe mode"
    aliases: [bs]
    cmds:
      - zig build -Doptimize=ReleaseSafe

  build:small:
    desc: "Build the project in ReleaseSmall mode"
    aliases: [bsm]
    cmds:
      - zig build -Doptimize=ReleaseSmall

  run:
    desc: "Build and run the project"
    aliases: [r]
    cmds:
      - zig build run

  run:release:
    desc: "Build and run the project in release mode"
    aliases: [rr]
    cmds:
      - zig build run -Doptimize=ReleaseFast

  test:
    desc: "Run all tests"
    aliases: [t]
    cmds:
      - zig build test

  test:file:
    desc: "Run tests for a specific file"
    aliases: [tf]
    cmds:
      - |
        if [ -z "{{.FILE}}" ]; then
          echo "Usage: task test:file FILE=<path>"
          echo "Example: task test:file FILE=src/json/pretty_print.zig"
          exit 1
        fi
        zig test {{.FILE}}

  test:summary:
    desc: "Run tests with summary output"
    aliases: [ts]
    cmds:
      - zig build test --summary all

  format:
    desc: "Format all Zig source files"
    aliases: [fmt, f]
    dir: "{{.TASKFILE_DIR}}"
    cmds:
      - zig fmt src/
      - zig fmt build.zig

  format:check:
    desc: "Check if code is formatted correctly"
    aliases: [fmt-check, fc]
    dir: "{{.TASKFILE_DIR}}"
    cmds:
      - zig fmt --check src/
      - zig fmt --check build.zig

  lint:
    desc: "Run linting checks"
    aliases: [l]
    cmds:
      - task: format:check
      - echo "‚úÖ Linting complete"

  clean:
    desc: "Clean build artifacts"
    aliases: [c]
    cmds:
      - rm -rf zig-out/
      - rm -rf zig-cache/
      - rm -rf .zig-cache/
      - echo "‚úÖ Cleaned build artifacts"

  check:
    desc: "Check the project (build without running)"
    cmds:
      - zig build --summary failures

  docs:
    desc: "Generate documentation"
    cmds:
      - echo "Generating documentation..."
      - zig build-lib src/root.zig -femit-docs -fno-emit-bin
      - echo "‚úÖ Documentation generated in zig-out/doc/"

  deps:
    desc: "Check dependencies and Zig installation"
    cmds:
      - zig version
      - zig env

  benchmark:
    desc: "Run benchmarks"
    aliases: [bench, bm]
    cmds:
      - echo "Running benchmarks..."
      - zig build test -Doptimize=ReleaseFast

  watch:
    desc: "Watch for changes and rebuild"
    aliases: [w]
    cmds:
      - |
        echo "Watching for changes... (Ctrl+C to stop)"
        while true; do
          zig build 2>&1 | grep -v "Build succeeded"
          inotifywait -e modify -r src/ build.zig 2>/dev/null || \
          fswatch -1 -r src/ build.zig 2>/dev/null || \
          sleep 2
        done

  watch:test:
    desc: "Watch for changes and run tests"
    aliases: [wt]
    cmds:
      - |
        echo "Watching for changes and running tests... (Ctrl+C to stop)"
        while true; do
          zig build test
          inotifywait -e modify -r src/ 2>/dev/null || \
          fswatch -1 -r src/ 2>/dev/null || \
          sleep 2
        done

  coverage:
    desc: "Generate test coverage report"
    cmds:
      - echo "Coverage reporting is not yet standardized in Zig"
      - echo "Consider using kcov or similar tools manually"

  analyze:
    desc: "Run static analysis"
    cmds:
      - zig build --verbose

  do:
    desc: "Run all pre-commit checks"
    cmds:
      - task: format
      - task: lint
      - task: test
      - echo "‚úÖ All checks passed"

  signoff:
    desc: "Sign off the codebase"
    aliases: ["sign", "s"]
    deps:
      - task: do
    cmds:
      - gh signoff

  install:
    desc: "Install the binary"
    cmds:
      - zig build -Doptimize=ReleaseFast
      - echo "Binary installed to {{.BUILD_DIR}}/bin/{{.PROJECT_NAME}}"

  uninstall:
    desc: "Remove installed binary"
    cmds:
      - rm -f {{.BUILD_DIR}}/bin/{{.PROJECT_NAME}}
      - echo "‚úÖ Binary removed"

  info:
    desc: "Show project information"
    cmds:
      - echo "Project {{.PROJECT_NAME}}"
      - echo "Build directory {{.BUILD_DIR}}"
      - zig version
      - echo ""
      - echo "Available build modes:"
      - echo "  - Debug (default)"
      - echo "  - ReleaseFast (task build:release)"
      - echo "  - ReleaseSafe (task build:safe)"
      - echo "  - ReleaseSmall (task build:small)"

  repl:
    desc: "Start Zig REPL (if available)"
    cmds:
      - |
        if command -v ziggy >/dev/null 2>&1; then
          ziggy
        else
          echo "No Zig REPL found. Install ziggy: https://github.com/zigtools/ziggy"
        fi

  update:protos:
    desc: "Update proto files"
    cmds:
      - buf export buf.build/tero/policy -o proto/policy
      - task: build:protos

  # =============================================================================
  # Build & Release
  # =============================================================================

  build:container:
    desc: "üê≥ Build container for a distribution (DIST=datadog|otlp|full)"
    dir: "{{.TASKFILE_DIR}}"
    vars:
      DIST: '{{.DIST | default "datadog"}}'
      GIT_SHA:
        sh: git rev-parse --short HEAD
    cmds:
      - |
        echo "üê≥ Building edge-{{.DIST}} container..."
        if [ -n "$CI" ]; then
          # CI: Use buildx with GitHub Actions cache
          docker buildx build \
            --build-arg DISTRIBUTION={{.DIST}} \
            --cache-from type=gha,scope=edge-{{.DIST}} \
            --cache-to type=gha,mode=max,scope=edge-{{.DIST}} \
            -t edge-{{.DIST}}:sha-{{.GIT_SHA}} \
            -t edge-{{.DIST}}:local \
            --load \
            .
        else
          # Local: Standard build
          DOCKER_BUILDKIT=1 docker build \
            --build-arg DISTRIBUTION={{.DIST}} \
            -t edge-{{.DIST}}:sha-{{.GIT_SHA}} \
            -t edge-{{.DIST}}:local \
            .
        fi
        echo "‚úÖ Built edge-{{.DIST}}:sha-{{.GIT_SHA}} (also tagged as edge-{{.DIST}}:local)"

  build:containers:
    desc: "üê≥ Build all distribution containers"
    cmds:
      - task: build:container
        vars: { DIST: "datadog" }

  push:container:
    desc: "üöÄ Push container to GCP Artifact Registry (DIST=datadog|otlp|full)"
    dir: "{{.TASKFILE_DIR}}"
    vars:
      DIST: '{{.DIST | default "datadog"}}'
      GIT_SHA:
        sh: git rev-parse --short HEAD
      GCP_PROJECT_ID:
        sh: echo "${GCP_PROJECT_ID:-usetero-dev}"
      GCP_REGION:
        sh: echo "${GCP_REGION:-us-central1}"
      GCP_REGISTRY:
        sh: echo "{{.GCP_REGION}}-docker.pkg.dev/{{.GCP_PROJECT_ID}}/edge"
    preconditions:
      - sh: docker image inspect edge-{{.DIST}}:sha-{{.GIT_SHA}} >/dev/null 2>&1
        msg: "Container edge-{{.DIST}}:sha-{{.GIT_SHA}} not found. Run 'task build:container DIST={{.DIST}}' first"
    cmds:
      - |
        echo "üöÄ Pushing edge-{{.DIST}} to GCP Artifact Registry..."
        # Tag for GCP registry
        docker tag edge-{{.DIST}}:sha-{{.GIT_SHA}} {{.GCP_REGISTRY}}/edge-{{.DIST}}:{{.GIT_SHA}}
        docker tag edge-{{.DIST}}:sha-{{.GIT_SHA}} {{.GCP_REGISTRY}}/edge-{{.DIST}}:latest
        # Push both tags
        docker push {{.GCP_REGISTRY}}/edge-{{.DIST}}:{{.GIT_SHA}}
        docker push {{.GCP_REGISTRY}}/edge-{{.DIST}}:latest
        echo "‚úÖ Pushed edge-{{.DIST}}:{{.GIT_SHA}} and edge-{{.DIST}}:latest"

  push:containers:
    desc: "üöÄ Push all distribution containers to GCP"
    cmds:
      - task: push:container
        vars: { DIST: "datadog" }

  release:
    desc: "üéØ Build and push all containers (for CI)"
    cmds:
      - task: build:containers
      - task: push:containers

  release:container:
    desc: "üéØ Build and push a specific distribution (DIST=datadog|otlp|full)"
    vars:
      DIST: '{{.DIST | default "datadog"}}'
    cmds:
      - task: build:container
        vars: { DIST: "{{.DIST}}" }
      - task: push:container
        vars: { DIST: "{{.DIST}}" }

  # =============================================================================
  # CI Setup
  # =============================================================================

  ci:setup:
    desc: "üîß Install CI/development dependencies (idempotent, safe to run locally)"
    dir: "{{.TASKFILE_DIR}}"
    cmds:
      - |
        echo "üîß Setting up CI environment..."

        # Clean up Docker resources to free disk space (important for CI with testcontainers)
        if [ -n "$CI" ]; then
          echo "üßπ Cleaning Docker resources in CI..."
          docker system prune -af --volumes 2>/dev/null || true
        fi

        echo "üîß Checking for required dependencies..."

        # Check for hyperscan/vectorscan (needed for catalog service)
        if ! pkg-config --exists libhs 2>/dev/null; then
          echo "üì¶ Installing hyperscan..."
          if [ "$(uname)" = "Darwin" ]; then
            # macOS: use vectorscan (hyperscan replacement)
            if command -v brew >/dev/null 2>&1; then
              brew install vectorscan pkg-config
            else
              echo "‚ö†Ô∏è  Homebrew not found. Install vectorscan manually or use Hermit."
            fi
          elif [ "$(uname)" = "Linux" ]; then
            # Linux: use hyperscan
            if command -v apt-get >/dev/null 2>&1; then
              sudo apt-get update && sudo apt-get install -y libhyperscan-dev pkg-config
            elif command -v yum >/dev/null 2>&1; then
              sudo yum install -y hyperscan-devel pkg-config
            else
              echo "‚ö†Ô∏è  Unknown package manager. Install hyperscan manually."
            fi
          else
            echo "‚ö†Ô∏è  Unknown platform: $(uname)"
          fi
        else
          echo "‚úÖ Hyperscan already installed"
        fi

        echo "‚úÖ CI setup complete"
